extends Node


## Autoload generated by the "GES - Godot Easy Saving" addon.
## This autoload manages all code related to the addon.
## Contributions are welcome! Feel free to open a Pull Request or report issues in the Issues section.


## This signal is emitted whenever a save file is loaded, regardless if it loaded corretly or not.
## Any errors are passed via [param error].
signal load_finished(error: Error)

## This signal is emitted whenever a save file is saved.
## The slot the file was saved to is passed via [param slot] and the file data is passed via [param saved_data].
signal save_finished(slot: int, saved_data: Dictionary)

## This signal is emitted whenever the data of the currently loaded save file changes.
## The new data is passed via [param new_data].
signal data_changed(new_data: Dictionary)


## The save files and encryption files path.
const FOLDER_PATH := "user://save/"


## The current data of the save file.
var data := {}

## The password used to encrypt save files. Unique to every single user.
var password := OS.get_unique_id()


func _ready() -> void:
	# Make sure this autoload runs even when the game is paused.
	process_mode = Node.PROCESS_MODE_ALWAYS


## Sets the [member data] [param key] to [param value] and emits [signal data_changed].
func push(key: String, value: Variant) -> void:
	data[key] = value


## Returns the [member data] [param key] current value. If it doesn't exist, [param default] is returned instead.
func pull(key: String, default: Variant = null) -> Variant:
	if data.has(key):
		return data[key]
	
	printerr("Trying to pull a key that doesn't exist. Returning the default value instead.")
	return default


## Loads the save file that corresponds to [param slot]. If the file doesn't exist, the default data is loaded instead.
func load_file(slot: int = 0) -> void:
	# Check if slot is a positive number.
	assert(slot >= 0, "Slot must be a positive number.")
	
	# Load the file.
	data = load_from_path(SaveHelper.get_save_file_path(slot), SaveHelper.is_slot_encrypted(slot))
	
	# Try to repair the file if it's damaged.
	var auto_repair: bool = SaveHelper.get_setting("auto_repair", true)
	var match_types: bool = SaveHelper.get_setting("match_types", true)
	var debug_log: bool = SaveHelper.get_setting("debug_log", true)
	
	if auto_repair:
		repair_keys()
	
	if match_types:
		repair_types()
	
	if debug_log:
		print("Data result after repairs: " + str(data))


## Adds missing keys to the loaded save file and also remove additional keys.
func repair_keys() -> void:
	# Get the default data.
	var default_data: Dictionary = SaveHelper.get_setting("save", {})
	var debug_log: bool = SaveHelper.get_setting("debug_log", true)
	
	# Add missing keys.
	data.merge(default_data)
	
	# Remove additional keys.
	for key: String in data.keys():
		if not default_data.has(key):
			if debug_log:
				print("Removed additional key \"%s\"." % key)
			
			data.erase(key)


## Checks if the type of all loaded save file values match the default data types.
## If not, reset the value to default.
func repair_types() -> void:
	# Get the default data.
	var default_data: Dictionary = SaveHelper.get_setting("save", {})
	var debug_log: bool = SaveHelper.get_setting("debug_log", true)
	
	# Loop trough every key.
	for key: String in data.keys():
		# Get values.
		var this_value: Variant = data[key]
		var default_value: Variant = default_data[key]
		
		# Get types.
		var this_type: Variant.Type = typeof(this_value)
		var default_type: Variant.Type = typeof(default_value)
		
		# If the types match - do nothing.
		if this_type == default_type:
			continue
		
		# Forgive ints and floats to prevent confusion.
		var is_forgiven := false
		var forgiven_map: Array[Array] = [
			# Forgive the loaded type if it can be found in the array with the expected type.
			[TYPE_INT, TYPE_FLOAT],
			[TYPE_VECTOR2I, TYPE_VECTOR2],
			[TYPE_VECTOR3I, TYPE_VECTOR3],
			[TYPE_VECTOR4I, TYPE_VECTOR4],
			[TYPE_PACKED_FLOAT32_ARRAY, TYPE_PACKED_FLOAT64_ARRAY, TYPE_PACKED_INT32_ARRAY, TYPE_PACKED_INT64_ARRAY],
		]
		
		for array: Array in forgiven_map:
			if array.has(this_type) and array.has(default_type):
				is_forgiven = true
		
		# But if the types don't match - reset the value to default.
		if is_forgiven:
			continue
		
		printerr("Value for key \"%s\" don't match its original value: Received %s (%s), expected %s (%s)." % [
			key,
			type_string(this_type),
			str(this_value),
			type_string(default_type),
			str(default_value),
		])
		
		this_value = default_value
		data[key] = this_value


## Saves the current [member data] to the file at the given [param slot]. If a file already exists at the given [param slot], it will be updated.
func save_file(slot: int = 0) -> void:
	# Check if slot is a positive number.
	assert(slot >= 0, "Slot must be a positive number.")
	
	# Get addon settings.
	var debug_log: bool = SaveHelper.get_setting("debug_log", true)
	var is_encrypted: bool = SaveHelper.get_setting("encrypted", true)
	
	# Create variables.
	var encryption_path := SaveHelper.get_encryption_file_path(slot)
	var file_path := SaveHelper.get_save_file_path(slot)
	
	# Create a folder to store all the save files if it doesn't exists yet.
	if not DirAccess.dir_exists_absolute(FOLDER_PATH):
		DirAccess.make_dir_absolute(FOLDER_PATH)
		
		if debug_log:
			print("Couldn't find saves folder. Created one just now.\nLocation: user://save/")
	
	# Create the .cfg file.
	var file: FileAccess
	if is_encrypted:
		file = FileAccess.open_encrypted_with_pass(file_path, FileAccess.WRITE, password)
	else:
		file = FileAccess.open(file_path, FileAccess.WRITE)
	
	# Store contents to the file.
	file.store_var(data)
	
	# Close the file.
	file.close()
	
	# Create or delete a file depending on the encryption state of the file.
	if is_encrypted:
		# Create a file to inform the addon that this save file is encrypted.
		if not FileAccess.file_exists(encryption_path):
			# Create file.
			file = FileAccess.open(encryption_path, FileAccess.WRITE)
			file.close()
			
			# Debug log.
			if debug_log:
				print("Created encryption file at \"%s\" because file \"%s\" is not encrypted." % [encryption_path, str(slot)])
		elif debug_log:
			# Debug log.
			print("No encryption files were created. Found an existing encryption file at \"%s\"." % encryption_path)
	else:
		# Remove a file to inform the addon that this save file is NOT encrypted.
		if FileAccess.file_exists(encryption_path):
			# Remove file.
			OS.move_to_trash(encryption_path)
			
			# Debug log.
			if debug_log:
				print("Removed encryption file at \"%s\" because file \"%s\" is not encrypted." % [encryption_path, str(slot)])
	
	# Log to the console.
	save_finished.emit(slot, data)
	if debug_log:
		print("Successfully save file %s at \"%s\"." % [str(slot), file_path])


## Loads a save file at the given [param path].
## If [param encrypted] doesn't match the file's encrypted state this method will fail.
func load_from_path(path: String, is_encrypted: bool) -> Dictionary:
	# Get the default save dictionary to be used in case something goes wrong.
	var debug_log: bool = SaveHelper.get_setting("debug_log", true)
	var default_dict: Dictionary = SaveHelper.get_setting("save", {})
	
	# Log the start of the load operation.
	if debug_log:
		print("Loading file from \"%s\" - Encrypted: %s." % [path, str(is_encrypted)])
	
	# Open the file in the given path.
	var file: FileAccess
	if is_encrypted:
		file = FileAccess.open_encrypted_with_pass(path, FileAccess.READ, password)
	else:
		file = FileAccess.open(path, FileAccess.READ)
	
	# Check for errors in the open process.
	var open_error := FileAccess.get_open_error()
	if open_error != OK:
		# Operation failed.
		printerr(error_string(open_error))
		load_finished.emit(open_error)
		
		return default_dict
	
	# Get the file as data.
	return file.get_var()
